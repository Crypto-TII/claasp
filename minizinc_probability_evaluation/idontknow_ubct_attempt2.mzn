array[0..31, 0..3, 0..3] of 0..4: tables_ubct = array3d(0..31, 0..3, 0..3, 
[
 4, 0, 2, 0,
 0, 0, 0, 0,
 0, 0, 2, 0,
 0, 0, 0, 0,

 0, 2, 0, 2,
 0, 2, 0, 0,
 0, 0, 0, 0,
 0, 0, 0, 2,

 0, 2, 0, 0,
 0, 2, 0, 0,
 0, 0, 0, 0,
 0, 0, 0, 0,

 2, 0, 0, 0,
 2, 0, 0, 0,
 0, 0, 0, 0,
 0, 0, 0, 0,

 2, 0, 2, 0,
 0, 0, 0, 0,
 2, 0, 2, 0,
 0, 0, 0, 0,

 0, 0, 0, 0,
 0, 0, 0, 0,
 0, 0, 0, 0,
 0, 0, 0, 0,

 0, 0, 0, 0,
 0, 2, 0, 0,
 0, 2, 0, 0,
 0, 0, 0, 0,

 0, 0, 0, 0,
 0, 0, 2, 0,
 0, 0, 2, 0,
 0, 0, 0, 0,

 2, 0, 2, 0,
 0, 0, 0, 0,
 2, 0, 2, 0,
 0, 0, 0, 0,

 0, 0, 0, 0,
 0, 0, 0, 0,
 0, 0, 0, 0,
 0, 0, 0, 0,

 0, 0, 0, 2,
 0, 0, 0, 0,
 0, 0, 0, 0,
 0, 0, 0, 2,

 2, 0, 0, 0,
 0, 0, 0, 0,
 0, 0, 0, 0,
 2, 0, 0, 0,

 2, 0, 0, 0,
 0, 0, 0, 0,
 2, 0, 4, 0,
 0, 0, 0, 0,

 0, 0, 0, 0,
 0, 2, 0, 0,
 0, 2, 0, 2,
 0, 0, 0, 2,

 0, 0, 0, 0,
 0, 0, 0, 0,
 0, 0, 0, 2,
 0, 0, 0, 2,

 0, 0, 0, 0,
 0, 0, 0, 0,
 0, 0, 2, 0,
 0, 0, 2, 0,

 0, 2, 0, 0,
 0, 2, 0, 0,
 0, 0, 0, 0,
 0, 0, 0, 0,

 2, 0, 0, 0,
 2, 0, 0, 0,
 0, 0, 0, 0,
 0, 0, 0, 0,

 2, 0, 0, 0,
 2, 0, 2, 0,
 0, 0, 2, 0,
 0, 0, 0, 0,

 0, 0, 0, 0,
 0, 4, 0, 2,
 0, 0, 0, 0,
 0, 0, 0, 2,

 0, 0, 0, 2,
 0, 0, 0, 0,
 0, 0, 0, 0,
 0, 0, 0, 2,

 2, 0, 0, 0,
 0, 0, 0, 0,
 0, 0, 0, 0,
 2, 0, 0, 0,

 0, 0, 0, 0,
 0, 0, 0, 0,
 0, 0, 0, 0,
 0, 0, 0, 0,

 0, 0, 0, 0,
 0, 2, 0, 2,
 0, 0, 0, 0,
 0, 2, 0, 2,

 0, 0, 0, 0,
 0, 2, 0, 0,
 0, 2, 0, 0,
 0, 0, 0, 0,

 0, 0, 0, 0,
 0, 0, 2, 0,
 0, 0, 2, 0,
 0, 0, 0, 0,

 0, 0, 0, 0,
 0, 0, 0, 0,
 0, 0, 0, 0,
 0, 0, 0, 0,

 0, 0, 0, 0,
 0, 2, 0, 2,
 0, 0, 0, 0,
 0, 2, 0, 2,

 0, 0, 0, 0,
 0, 0, 0, 0,
 0, 0, 0, 2,
 0, 0, 0, 2,

 0, 0, 0, 0,
 0, 0, 0, 0,
 0, 0, 2, 0,
 0, 0, 2, 0,

 2, 0, 0, 0,
 0, 0, 0, 0,
 0, 0, 2, 0,
 2, 0, 2, 0,

 0, 0, 0, 0,
 0, 2, 0, 0,
 0, 0, 0, 0,
 0, 2, 0, 4]);
 
array[0..3,0..1] of 0..1: valid_state_ubct = array2d(0..3,0..1,
 [ 0,0,
   1,0,
   1,1,
   0,1
]);
 
int: nbit = 16;

array[0..nbit-1] of var 0..1: dL = array1d(0..nbit-1, [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0]);
array[0..nbit-1] of var 0..1: dR = array1d(0..nbit-1, [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);
array[0..nbit-1] of var 0..1: nL = array1d(0..nbit-1, [0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0]);
array[0..nbit-1] of var 0..1: nR = array1d(0..nbit-1, [0,0,0,0,1,0,0,0,0,0,0,1,1,1,0,0]);
array[0..nbit-1] of var 0..1: dLL = array1d(0..nbit-1,[1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0]);

predicate ubct_compute(
    array[0..nbit-1] of var 0..1: dL,
    array[0..nbit-1] of var 0..1: dR,
    array[0..nbit-1] of var 0..1: nL,
    array[0..nbit-1] of var 0..1: nR,
    array[0..nbit-1] of var 0..1: dLL,
    var int: ubct_prob
) =
let {
    array[1..nbit-1,0..3] of var int: dp_ubct;
    array[1..nbit-1] of var 0..31: tmp0;
    var int: ubct_value;
} in
(
    tmp0[1] = dLL[nbit-1]*16 + nR[nbit-1]*8 + nL[nbit-1]*4 + dR[nbit-1]*2 + dL[nbit-1]*1 /\

    dp_ubct[1,0] = tables_ubct[tmp0[1],0,0] /\
    dp_ubct[1,1] = tables_ubct[tmp0[1],1,0] /\
    dp_ubct[1,2] = tables_ubct[tmp0[1],2,0] /\
    dp_ubct[1,3] = tables_ubct[tmp0[1],3,0] /\

    forall(i in 2..nbit-1)(
        tmp0[i] = dLL[nbit-i]*16 + nR[nbit-i]*8 + nL[nbit-i]*4 + dR[nbit-i]*2 + dL[nbit-i]*1 /\
        forall(j in 0..3)(
            dp_ubct[i,j] = sum(k in 0..3)(dp_ubct[i-1,k] * tables_ubct[tmp0[i],j,k])
        )
    ) /\

    ubct_value =
        4 * sum(state in 0..3)(
            if (valid_state_ubct[state,0] + valid_state_ubct[state,1]
                + dLL[1] + nR[1] + nL[1]) mod 2 = 0
            then dp_ubct[nbit-1,state]
            else 0 endif
        ) /\

    ubct_prob = floor((-log2(ubct_value) + 32) * 100)
);

var int: ubct_prob;

constraint ubct_compute(dL, dR, nL, nR, dLL, ubct_prob);


output[
      "ubct_entry/2^32 = \(ubct_prob)"
      ];